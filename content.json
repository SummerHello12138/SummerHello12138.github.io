{"meta":{"title":"Summer's 博客","subtitle":"一只菜鸟级的安全狗","description":"～信息安全专业，最近开始对插画有兴趣～","author":"Xia Benhui","url":"https://SummerHello12138.github.io"},"pages":[{"title":"archives","date":"2018-09-16T10:41:11.000Z","updated":"2018-09-16T10:44:43.601Z","comments":true,"path":"archives/index.html","permalink":"https://SummerHello12138.github.io/archives/index.html","excerpt":"","text":""},{"title":"about","date":"2018-09-16T10:38:05.000Z","updated":"2018-09-16T10:38:05.151Z","comments":true,"path":"about/index.html","permalink":"https://SummerHello12138.github.io/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2018-09-16T10:41:00.000Z","updated":"2018-09-16T10:43:45.262Z","comments":true,"path":"categories/index.html","permalink":"https://SummerHello12138.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-09-16T10:40:39.000Z","updated":"2018-09-16T10:44:08.006Z","comments":true,"path":"tags/index.html","permalink":"https://SummerHello12138.github.io/tags/index.html","excerpt":"","text":""},{"title":"timeline","date":"2018-09-16T10:41:22.000Z","updated":"2018-09-16T10:46:22.208Z","comments":true,"path":"timeline/index.html","permalink":"https://SummerHello12138.github.io/timeline/index.html","excerpt":"","text":""}],"posts":[{"title":"图的遍历","slug":"15366684711365","date":"2018-09-11T12:21:11.138Z","updated":"2018-09-15T14:25:25.404Z","comments":true,"path":"2018/09/11/15366684711365/","link":"","permalink":"https://SummerHello12138.github.io/2018/09/11/15366684711365/","excerpt":"","text":"DFS123456789101112131415161718192021/* 邻接矩阵的深度优先递归算法 */void DFS(MGraph G, int i)&#123; int j; visited[i] = TRUE; printf(\"%c \", G.vexs[i]);/* 打印顶点，也可以其它操作 */ for(j = 0; j &lt; G.numVertexes; j++) if(G.arc[i][j] == 1 &amp;&amp; !visited[j]) DFS(G, j);/* 对为访问的邻接顶点递归调用 */&#125;/* 邻接矩阵的深度遍历操作 */void DFSTraverse(MGraph G)&#123; int i; for(i = 0; i &lt; G.numVertexes; i++) visited[i] = FALSE; /* 初始所有顶点状态都是未访问过状态 */ for(i = 0; i &lt; G.numVertexes; i++) if(!visited[i]) /* 对未访问过的顶点调用DFS，若是连通图，只会执行一次 */ DFS(G, i);&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/* 利用邻接矩阵构建邻接表 */void CreateALGraph(MGraph G,GraphAdjList *GL)&#123; int i,j; EdgeNode *e; *GL = (GraphAdjList)malloc(sizeof(graphAdjList)); (*GL)-&gt;numVertexes=G.numVertexes; (*GL)-&gt;numEdges=G.numEdges; for(i= 0;i &lt;G.numVertexes;i++) /* 读入顶点信息,建立顶点表 */ &#123; (*GL)-&gt;adjList[i].in=0; (*GL)-&gt;adjList[i].data=G.vexs[i]; (*GL)-&gt;adjList[i].firstedge=NULL; /* 将边表置为空表 */ &#125; for(i=0;i&lt;G.numVertexes;i++) /* 建立边表 */ &#123; for(j=0;j&lt;G.numVertexes;j++) &#123; if (G.arc[i][j]==1) &#123; e=(EdgeNode *)malloc(sizeof(EdgeNode)); e-&gt;adjvex=j; /* 邻接序号为j */ e-&gt;next=(*GL)-&gt;adjList[i].firstedge; /* 将当前顶点上的指向的结点指针赋值给e */ (*GL)-&gt;adjList[i].firstedge=e; /* 将当前顶点的指针指向e */ (*GL)-&gt;adjList[j].in++; &#125; &#125; &#125; &#125;Boolean visited[MAXSIZE]; /* 访问标志的数组 *//* 邻接表的深度优先递归算法 */void DFS(GraphAdjList GL, int i)&#123; EdgeNode *p; visited[i] = TRUE; printf(\"%c \",GL-&gt;adjList[i].data);/* 打印顶点,也可以其它操作 */ p = GL-&gt;adjList[i].firstedge; while(p) &#123; if(!visited[p-&gt;adjvex]) DFS(GL, p-&gt;adjvex);/* 对为访问的邻接顶点递归调用 */ p = p-&gt;next; &#125;&#125;/* 邻接表的深度遍历操作 */void DFSTraverse(GraphAdjList GL)&#123; int i; for(i = 0; i &lt; GL-&gt;numVertexes; i++) visited[i] = FALSE; /* 初始所有顶点状态都是未访问过状态 */ for(i = 0; i &lt; GL-&gt;numVertexes; i++) if(!visited[i]) /* 对未访问过的顶点调用DFS,若是连通图,只会执行一次 */ DFS(GL, i);&#125; BFS1234567891011121314151617181920212223242526272829303132/* 邻接矩阵的广度遍历算法 */void BFSTraverse(MGraph G)&#123; int i, j; Queue Q; for(i = 0; i &lt; G.numVertexes; i++) visited[i] = FALSE; InitQueue(&amp;Q); /* 初始化一辅助用的队列 */ for(i = 0; i &lt; G.numVertexes; i++) /* 对每一个顶点做循环 */ &#123; if (!visited[i]) /* 若是未访问过就处理 */ &#123; visited[i]=TRUE; /* 设置当前顶点访问过 */ printf(\"%c \", G.vexs[i]);/* 打印顶点，也可以其它操作 */ EnQueue(&amp;Q,i); /* 将此顶点入队列 */ while(!QueueEmpty(Q)) /* 若当前队列不为空 */ &#123; DeQueue(&amp;Q,&amp;i); /* 将队对元素出队列，赋值给i */ for(j=0;j&lt;G.numVertexes;j++) &#123; /* 判断其它顶点若与当前顶点存在边且未访问过 */ if(G.arc[i][j] == 1 &amp;&amp; !visited[j]) &#123; visited[j]=TRUE; /* 将找到的此顶点标记为已访问 */ printf(\"%c \", G.vexs[j]); /* 打印顶点 */ EnQueue(&amp;Q,j); /* 将找到的此顶点入队列 */ &#125; &#125; &#125; &#125; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334/* 邻接表的广度遍历算法 */void BFSTraverse(GraphAdjList GL)&#123; int i; EdgeNode *p; Queue Q; for(i = 0; i &lt; GL-&gt;numVertexes; i++) visited[i] = FALSE; InitQueue(&amp;Q); for(i = 0; i &lt; GL-&gt;numVertexes; i++) &#123; if (!visited[i]) &#123; visited[i]=TRUE; printf(\"%c \",GL-&gt;adjList[i].data);/* 打印顶点,也可以其它操作 */ EnQueue(&amp;Q,i); while(!QueueEmpty(Q)) &#123; DeQueue(&amp;Q,&amp;i); p = GL-&gt;adjList[i].firstedge; /* 找到当前顶点的边表链表头指针 */ while(p) &#123; if(!visited[p-&gt;adjvex]) /* 若此顶点未被访问 */ &#123; visited[p-&gt;adjvex]=TRUE; printf(\"%c \",GL-&gt;adjList[p-&gt;adjvex].data); EnQueue(&amp;Q,p-&gt;adjvex); /* 将此顶点入队列 */ &#125; p = p-&gt;next; /* 指针指向下一个邻接点 */ &#125; &#125; &#125; &#125;&#125;","categories":[],"tags":[]},{"title":"计算机组成原理","slug":"计算机组成原理","date":"2018-07-27T03:11:11.421Z","updated":"2018-09-15T14:25:12.093Z","comments":true,"path":"2018/07/27/计算机组成原理/","link":"","permalink":"https://SummerHello12138.github.io/2018/07/27/计算机组成原理/","excerpt":"","text":"概述0x00. 计算机发展1. 第一代（1946～1957）：电子管时代容量小、体积庞大、成本高、运算速度低，一般每秒几千到几万次 2. 第二代（1958～1964）：晶体管时代运算速度提高到每秒几万到几十万次，操作系统雏形 3. 第三代（1965～1971）：中小规模集成电路时代出现分时操作系统 4. 第四代（1972～今）：超大规模集成电路时代0x01. 摩尔定律摩尔定律，当价格不变时，集成电路上可容纳的晶体管数目，约每隔18个月便会增加一倍，性能也将提升一倍。 0x02. 计算机的分类1）电子计算机分为电子模拟计算机和电子数字计算机。2）用途：专用计算机、通用计算机3）通用计算机：巨型机、大型机、小型机、微型机、单片机4）指令和数据流： 单指令和单数据流系统（SISD），冯·诺依曼系统 单指令和多数据流系统（SIMD），阵列处理器和向量处理器 多指令和单数据流系统（MISD），不存在 多指令和多数据流系统（MIMD），多处理器和多计算机系统 0x03. 计算机硬件组成1. 早期冯·诺依曼机结构：原因：早期运算器和控制器分离，存储器容量很小，故而设计成以运算器为中心，其他部件都通过运算器完成信息的传递。 特点：1）计算机硬件系统由运算器、存储器、控制器、输入设备和输出设备组成2）指令和数据以同等地位存于存储器内，并可以按地址寻访3）指令和数据均用二进制代码表示4）指令由操作码和地址码组成，操作码用来表示操作的性质，地址码用来表示操作数载存储器中的位置5）指令在存储器内按顺序存放6）早期的冯·诺伊曼机以运算器为中心 2. 现代计算机结构结构：原因：I/O操作尽可能绕过CPU，直接在I/O设备和存储器之间完成，以提高系统的整体运行效率。 功能部件：1）输入设备将程序和数据以机器所能识别和接受的信息形式输入到计算机 2）输出设备将计算机处理的结果以人们所能接受的形式或其他系统所要求的信息形式输出 3）存储器存储器是计算机的存储部件，用来存放程序和数据存储器分为主存储器（也称为内存储器）和辅助存储器（也称为外存储器）。 主存储器的结构： 地址寄存器（MAR）存放访存地址，经过地址译码后找到所选的存储单元。位数对应着存储单元的个数，如MAR为10位，则有${2}^{10}=1024B=1K$个存储单元。MAR的长度与PC长度相等。数据寄存器（MDR）是主存和其他部件的中介机构，用于暂存要从存储器中读或写的信息。MDR的位数和存储字长相等，一般为字节的二次幂整数倍，如8位、16位、32位、64位等。 4）运算器计算机的执行部件，用于对数据进行加工处理，完成算术运算和逻辑运算运算器的核心是算术逻辑单元ALU，包含若干通用寄存器，如累加器（ACC）、乘商寄存器（MQ）、操作数寄存器（X）、变址寄存器（IX）、基址寄存器（BR）等。运算器还包含程序状态寄存器（PSW）。 5）控制器计算机的指挥中心，指挥各部件自动协调地进行工作控制器由程序计数器（PC）、指令寄存器（IR）、控制单元（CU）组成。 0x04. 计算机软件分类1. 系统软件是一组保证计算机系统高效、正确运行的基础软件，通常作为系统资源提供给用户使用。 2. 应用软件是指用户为解决某个应用领域中的各类问题而编制的程序。注：数据库管理系统（DBMS）是位于用户和操作系统之间的一层数据管理软件，是系统软件；数据库系统（DBS）是指计算机系统中引入数据库后的系统，一般由数据库、数据库管理系统、数据库管理员（DBA）和应用系统构成。 0x05. 计算机工作过程1）把程序和数据装入到主存储器中2）从程序的起始地址运行程序3）用程序的首地址从存储器中取第一条指令，经过译码、执行步骤等控制计算机各功能部件协同运行，完成该指令功能，并计算下一条指令地址。4）用新得到的指令地址继续读出第二条指令并执行，直到程序结束为止 例：将指令地址码指示的存储单元中的操作数取出后送至运算器的ACC中（操作码为OP(IR)，地址码为Ad(IR)）取指令：PC-&gt;MAR-&gt;M-&gt;MDR-&gt;IR; (PC)+1-&gt;PC分析指令：OP(IR)-&gt;CU执行指令：Ad(IR)-&gt;MAR-&gt;M-&gt;MDR-&gt;ACC 0x06. 计算机系统多层次结构1. 微程序机器层由机器硬件直接执行微指令 2. 传统机器语言层由微程序解释机器指令系统 3. 操作系统层混合层，包含机器指令和广义指令。 4. 汇编语言层由汇编程序支持和执行 5. 高级语言层面向用户，由高级语言编译程序支持和执行 本课程讨论第一层和第二层的组成原理与设计。","categories":[],"tags":[]}]}