{"meta":{"title":"Summer's 博客","subtitle":"一只菜鸟级的安全狗","description":"～信息安全专业，最近开始对插画有兴趣～","author":"Xia Benhui","url":"https://SummerHello12138.github.io"},"pages":[{"title":"about","date":"2018-09-16T10:38:05.000Z","updated":"2018-09-16T11:46:32.035Z","comments":true,"path":"about/index.html","permalink":"https://SummerHello12138.github.io/about/index.html","excerpt":"","text":"Email：1539237212@qq.comUniversity：中国矿业大学"},{"title":"tags","date":"2018-09-16T10:40:39.000Z","updated":"2018-09-16T10:44:08.006Z","comments":true,"path":"tags/index.html","permalink":"https://SummerHello12138.github.io/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2018-09-16T10:41:00.000Z","updated":"2018-09-16T10:43:45.262Z","comments":true,"path":"categories/index.html","permalink":"https://SummerHello12138.github.io/categories/index.html","excerpt":"","text":""},{"title":"archives","date":"2018-09-16T10:41:11.000Z","updated":"2018-09-16T10:44:43.601Z","comments":true,"path":"archives/index.html","permalink":"https://SummerHello12138.github.io/archives/index.html","excerpt":"","text":""},{"title":"timeline","date":"2018-09-16T10:41:22.000Z","updated":"2018-09-16T10:46:22.208Z","comments":true,"path":"timeline/index.html","permalink":"https://SummerHello12138.github.io/timeline/index.html","excerpt":"","text":""}],"posts":[{"title":"2019计算机考研大纲","slug":"考研大纲","date":"2018-09-16T10:04:06.335Z","updated":"2018-09-16T11:34:02.083Z","comments":true,"path":"2018/09/16/考研大纲/","link":"","permalink":"https://SummerHello12138.github.io/2018/09/16/考研大纲/","excerpt":"数据结构【考查目标】 掌握数据结构的基本概念、基本原理和基本方法。 掌握数据结构的逻辑结构、存储结构及基本操作的实现，能够对算法进行基本的时间复杂度与空间复杂度的分析。 能够运用数据结构基本原理和方法进行问题的分析与求解，具备采用C或C++语言设计与实现算法的能力。 一、线性表（一）线性表的定义和基本操作（二）线性表的实现1）顺序存储2）链式存储3）线性表的应用 二、栈、队列和数组（一）栈和队列的基本概念（二）栈和队列的顺序存储结构（三）栈和队列的链式存储结构（四）栈和队列的应用（五）特殊矩阵的压缩存储","text":"数据结构【考查目标】 掌握数据结构的基本概念、基本原理和基本方法。 掌握数据结构的逻辑结构、存储结构及基本操作的实现，能够对算法进行基本的时间复杂度与空间复杂度的分析。 能够运用数据结构基本原理和方法进行问题的分析与求解，具备采用C或C++语言设计与实现算法的能力。 一、线性表（一）线性表的定义和基本操作（二）线性表的实现1）顺序存储2）链式存储3）线性表的应用 二、栈、队列和数组（一）栈和队列的基本概念（二）栈和队列的顺序存储结构（三）栈和队列的链式存储结构（四）栈和队列的应用（五）特殊矩阵的压缩存储三、树与二叉树（一）树的基本概念（二）二叉树1）二叉树的定义及其主要特征2）二叉树的顺序存储结构和链式存储结构3）二叉树的遍历4）线索二叉树的基本概念和构造（三）树、森林1）树的存储结构2）森林与二叉树的转换3）树和森林的遍历（四）树与二叉树的应用1）二叉排序树2）平衡二叉树3）哈夫曼（Huffman）树和哈夫曼编码 四、图(一)图的基本概念(二)图的存储及基本操作1）邻接矩阵法2）邻接表法3）邻接多重表、十字链表(三)图的遍历1）深度优先搜索（DFS）2）广度优先搜索（BFS）(四)图的基本应用1）最小（代价）生成树2）最短路径3）拓扑排序4）关键路径 五、查找(一)查找的基本概念(二)顺序查找法(三)分块查找法(四)折半查找法(五)B树及其基本操作、B+树的基本概念(六)散列(Hash)表(七)字符串模式匹配(八)查找算法的分析及应用 六、排序(一)排序的基本概念(二)插入排序1）直接插入排序2）折半插入排序(三)起泡排序(BubbleSort)(四)简单选择排序(五)希尔排序(ShellSort)(六)快速排序(七)堆排序(八)二路归并排序(MergeSort)(九)基数排序(十)外部排序(十一)各种排序算法的比较(十二)排序算法的应用 计算机组成原理【考查目标】 理解单处理器计算机系统中各部件的内部工作原理、组成结构以及相互连接方式，具有完整的计算机系统的整机概念。 理解计算机系统层次化结构概念，熟悉硬件与软件之间的界面，掌握指令集体系结构的基本知识和基本实现方法。 能够综合运用计算机组成的基本原理和基本方法，对有关计算机硬件系统中的理论和实际问题进行计算、分析，对一些基本部件进行简单设计;并能对高级程序设计语言(如C语言)中的相关问题进行分析。 一、计算机系统概述(一)计算机发展历程(二)计算机系统层次结构 计算机系统的基本组成 计算机硬件的基本组成 计算机软件和硬件的关系 计算机系统的工作过程 (三)计算机性能指标吞吐量、响应时间，CPU时钟周期、主频、CPI、CPU执行时间，MIPS、MFLOPS、GFLOPS、TFLOPS、PFLOPS。二、数据的表示和运算(一)数制与编码 进位计数制及其相互转换 真值和机器数 BCD码 字符与字符串 校验码 (二)定点数的表示和运算 定点数的表示无符号数的表示，带符号整数的表示。 定点数的运算定点数的位移运算，原码定点数的加/减运算，补码定点数的加/减运算，定点数的乘/除运算，溢出概念和判别方法。 (三)浮点数的表示和运算 浮点数的表示IEEE754标准。 浮点数的加/减运算 (四)算术逻辑单元ALU 串行加法器和并行加法器 算术逻辑单元ALU的功能和结构 三、存储器层次结构(一)存储器的分类(二)存储器的层次化结构(三)半导体随机存取存储器 1.SRAM存储器 2.DRAM存储器 3.只读存储器 4.Flash存储器(四)主存储器与CPU的连接(五)双口RAM和多模块存储器(六)高速缓冲存储器(Cache) 1.Cache的基本工作原理 2.Cach和主存之间的映射方式 3.Cache中主存块的替换算法 4.Cache写策略(七)虚拟存储器 1.虚拟存储器的基本概念 2.页式虚拟存储器 3.段式虚拟存储器 4.段页式虚拟存储器 5.TLB(快表)四、指令系统(一)指令格式 1.指令的基本格式 2.定长操作码指令格式 3.扩展操作码指令格式(二)指令的寻址方式 1.有效地址的概念 2.数据寻址和指令寻址 3.常见寻址方式(三)CISC和RISC的基本概念五、中央处理器（CPU）(一)CPU的功能和基本结构(二)指令执行过程(三)数据通路的功能和基本结构(四)控制器的功能和工作原理 1.硬布线控制器 2.微程序控制器 微程序、微指令和微命令，微指令格式，微命令的编码方式，微地址的形成方式。(五)指令流水线 1.指令流水线的基本概念 2.指令流水线的基本实现 3.超标量和动态流水线的基本概念六、总线(一)总线概述 1.总线的基本概念 2.总线的分类 3.总线的组成及性能指标(二)总线仲裁 1.集中仲裁方式 2.分布仲裁方式(三)总线操作和定时 1.同步定时方式 2.异步定时方式(四)总线标准七、输入输出（I/O）系统(一)I/O系统基本概念(二)外部设备 1.输入设备：键盘、鼠标 2.输出设备：显示器、打印机 3.外存储器：硬盘存储器、磁盘阵列、光盘存储器(三)I/O接口(I/O控制器) 1.I/O接口的功能和基本结构 2.I/O端口及其编址(四)I/O方式 1.程序查询方式 2.程序中断方式 中断的基本概念，中断响应过程，中断处理过程，多重中断和中断屏蔽的概念。 3.DMA方式 DMA控制器的组成，DMA传送过程。","categories":[{"name":"考研","slug":"考研","permalink":"https://SummerHello12138.github.io/categories/考研/"}],"tags":[{"name":"考研","slug":"考研","permalink":"https://SummerHello12138.github.io/tags/考研/"},{"name":"数据结构","slug":"数据结构","permalink":"https://SummerHello12138.github.io/tags/数据结构/"},{"name":"计算机组成原理","slug":"计算机组成原理","permalink":"https://SummerHello12138.github.io/tags/计算机组成原理/"}]},{"title":"图的遍历","slug":"15366684711365","date":"2018-09-11T12:21:11.138Z","updated":"2018-09-16T11:33:56.453Z","comments":true,"path":"2018/09/11/15366684711365/","link":"","permalink":"https://SummerHello12138.github.io/2018/09/11/15366684711365/","excerpt":"DFS123456789101112131415161718192021/* 邻接矩阵的深度优先递归算法 */void DFS(MGraph G, int i)&#123; int j; visited[i] = TRUE; printf(\"%c \", G.vexs[i]);/* 打印顶点，也可以其它操作 */ for(j = 0; j &lt; G.numVertexes; j++) if(G.arc[i][j] == 1 &amp;&amp; !visited[j]) DFS(G, j);/* 对为访问的邻接顶点递归调用 */&#125;/* 邻接矩阵的深度遍历操作 */void DFSTraverse(MGraph G)&#123; int i; for(i = 0; i &lt; G.numVertexes; i++) visited[i] = FALSE; /* 初始所有顶点状态都是未访问过状态 */ for(i = 0; i &lt; G.numVertexes; i++) if(!visited[i]) /* 对未访问过的顶点调用DFS，若是连通图，只会执行一次 */ DFS(G, i);&#125;","text":"DFS123456789101112131415161718192021/* 邻接矩阵的深度优先递归算法 */void DFS(MGraph G, int i)&#123; int j; visited[i] = TRUE; printf(\"%c \", G.vexs[i]);/* 打印顶点，也可以其它操作 */ for(j = 0; j &lt; G.numVertexes; j++) if(G.arc[i][j] == 1 &amp;&amp; !visited[j]) DFS(G, j);/* 对为访问的邻接顶点递归调用 */&#125;/* 邻接矩阵的深度遍历操作 */void DFSTraverse(MGraph G)&#123; int i; for(i = 0; i &lt; G.numVertexes; i++) visited[i] = FALSE; /* 初始所有顶点状态都是未访问过状态 */ for(i = 0; i &lt; G.numVertexes; i++) if(!visited[i]) /* 对未访问过的顶点调用DFS，若是连通图，只会执行一次 */ DFS(G, i);&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/* 利用邻接矩阵构建邻接表 */void CreateALGraph(MGraph G,GraphAdjList *GL)&#123; int i,j; EdgeNode *e; *GL = (GraphAdjList)malloc(sizeof(graphAdjList)); (*GL)-&gt;numVertexes=G.numVertexes; (*GL)-&gt;numEdges=G.numEdges; for(i= 0;i &lt;G.numVertexes;i++) /* 读入顶点信息,建立顶点表 */ &#123; (*GL)-&gt;adjList[i].in=0; (*GL)-&gt;adjList[i].data=G.vexs[i]; (*GL)-&gt;adjList[i].firstedge=NULL; /* 将边表置为空表 */ &#125; for(i=0;i&lt;G.numVertexes;i++) /* 建立边表 */ &#123; for(j=0;j&lt;G.numVertexes;j++) &#123; if (G.arc[i][j]==1) &#123; e=(EdgeNode *)malloc(sizeof(EdgeNode)); e-&gt;adjvex=j; /* 邻接序号为j */ e-&gt;next=(*GL)-&gt;adjList[i].firstedge; /* 将当前顶点上的指向的结点指针赋值给e */ (*GL)-&gt;adjList[i].firstedge=e; /* 将当前顶点的指针指向e */ (*GL)-&gt;adjList[j].in++; &#125; &#125; &#125; &#125;Boolean visited[MAXSIZE]; /* 访问标志的数组 *//* 邻接表的深度优先递归算法 */void DFS(GraphAdjList GL, int i)&#123; EdgeNode *p; visited[i] = TRUE; printf(\"%c \",GL-&gt;adjList[i].data);/* 打印顶点,也可以其它操作 */ p = GL-&gt;adjList[i].firstedge; while(p) &#123; if(!visited[p-&gt;adjvex]) DFS(GL, p-&gt;adjvex);/* 对为访问的邻接顶点递归调用 */ p = p-&gt;next; &#125;&#125;/* 邻接表的深度遍历操作 */void DFSTraverse(GraphAdjList GL)&#123; int i; for(i = 0; i &lt; GL-&gt;numVertexes; i++) visited[i] = FALSE; /* 初始所有顶点状态都是未访问过状态 */ for(i = 0; i &lt; GL-&gt;numVertexes; i++) if(!visited[i]) /* 对未访问过的顶点调用DFS,若是连通图,只会执行一次 */ DFS(GL, i);&#125; BFS1234567891011121314151617181920212223242526272829303132/* 邻接矩阵的广度遍历算法 */void BFSTraverse(MGraph G)&#123; int i, j; Queue Q; for(i = 0; i &lt; G.numVertexes; i++) visited[i] = FALSE; InitQueue(&amp;Q); /* 初始化一辅助用的队列 */ for(i = 0; i &lt; G.numVertexes; i++) /* 对每一个顶点做循环 */ &#123; if (!visited[i]) /* 若是未访问过就处理 */ &#123; visited[i]=TRUE; /* 设置当前顶点访问过 */ printf(\"%c \", G.vexs[i]);/* 打印顶点，也可以其它操作 */ EnQueue(&amp;Q,i); /* 将此顶点入队列 */ while(!QueueEmpty(Q)) /* 若当前队列不为空 */ &#123; DeQueue(&amp;Q,&amp;i); /* 将队对元素出队列，赋值给i */ for(j=0;j&lt;G.numVertexes;j++) &#123; /* 判断其它顶点若与当前顶点存在边且未访问过 */ if(G.arc[i][j] == 1 &amp;&amp; !visited[j]) &#123; visited[j]=TRUE; /* 将找到的此顶点标记为已访问 */ printf(\"%c \", G.vexs[j]); /* 打印顶点 */ EnQueue(&amp;Q,j); /* 将找到的此顶点入队列 */ &#125; &#125; &#125; &#125; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334/* 邻接表的广度遍历算法 */void BFSTraverse(GraphAdjList GL)&#123; int i; EdgeNode *p; Queue Q; for(i = 0; i &lt; GL-&gt;numVertexes; i++) visited[i] = FALSE; InitQueue(&amp;Q); for(i = 0; i &lt; GL-&gt;numVertexes; i++) &#123; if (!visited[i]) &#123; visited[i]=TRUE; printf(\"%c \",GL-&gt;adjList[i].data);/* 打印顶点,也可以其它操作 */ EnQueue(&amp;Q,i); while(!QueueEmpty(Q)) &#123; DeQueue(&amp;Q,&amp;i); p = GL-&gt;adjList[i].firstedge; /* 找到当前顶点的边表链表头指针 */ while(p) &#123; if(!visited[p-&gt;adjvex]) /* 若此顶点未被访问 */ &#123; visited[p-&gt;adjvex]=TRUE; printf(\"%c \",GL-&gt;adjList[p-&gt;adjvex].data); EnQueue(&amp;Q,p-&gt;adjvex); /* 将此顶点入队列 */ &#125; p = p-&gt;next; /* 指针指向下一个邻接点 */ &#125; &#125; &#125; &#125;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://SummerHello12138.github.io/categories/数据结构/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://SummerHello12138.github.io/tags/数据结构/"},{"name":"图","slug":"图","permalink":"https://SummerHello12138.github.io/tags/图/"}]},{"title":"计算机组成原理","slug":"计算机组成原理","date":"2018-07-27T03:11:11.421Z","updated":"2018-09-16T11:33:49.585Z","comments":true,"path":"2018/07/27/计算机组成原理/","link":"","permalink":"https://SummerHello12138.github.io/2018/07/27/计算机组成原理/","excerpt":"0x00. 计算机发展1. 第一代（1946～1957）：电子管时代容量小、体积庞大、成本高、运算速度低，一般每秒几千到几万次 2. 第二代（1958～1964）：晶体管时代运算速度提高到每秒几万到几十万次，操作系统雏形 3. 第三代（1965～1971）：中小规模集成电路时代出现分时操作系统 4. 第四代（1972～今）：超大规模集成电路时代0x01. 摩尔定律摩尔定律，当价格不变时，集成电路上可容纳的晶体管数目，约每隔18个月便会增加一倍，性能也将提升一倍。","text":"0x00. 计算机发展1. 第一代（1946～1957）：电子管时代容量小、体积庞大、成本高、运算速度低，一般每秒几千到几万次 2. 第二代（1958～1964）：晶体管时代运算速度提高到每秒几万到几十万次，操作系统雏形 3. 第三代（1965～1971）：中小规模集成电路时代出现分时操作系统 4. 第四代（1972～今）：超大规模集成电路时代0x01. 摩尔定律摩尔定律，当价格不变时，集成电路上可容纳的晶体管数目，约每隔18个月便会增加一倍，性能也将提升一倍。 0x02. 计算机的分类1）电子计算机分为电子模拟计算机和电子数字计算机。2）用途：专用计算机、通用计算机3）通用计算机：巨型机、大型机、小型机、微型机、单片机4）指令和数据流： 单指令和单数据流系统（SISD），冯·诺依曼系统 单指令和多数据流系统（SIMD），阵列处理器和向量处理器 多指令和单数据流系统（MISD），不存在 多指令和多数据流系统（MIMD），多处理器和多计算机系统 0x03. 计算机硬件组成1. 早期冯·诺依曼机结构：原因：早期运算器和控制器分离，存储器容量很小，故而设计成以运算器为中心，其他部件都通过运算器完成信息的传递。 特点：1）计算机硬件系统由运算器、存储器、控制器、输入设备和输出设备组成2）指令和数据以同等地位存于存储器内，并可以按地址寻访3）指令和数据均用二进制代码表示4）指令由操作码和地址码组成，操作码用来表示操作的性质，地址码用来表示操作数载存储器中的位置5）指令在存储器内按顺序存放6）早期的冯·诺伊曼机以运算器为中心 2. 现代计算机结构结构：原因：I/O操作尽可能绕过CPU，直接在I/O设备和存储器之间完成，以提高系统的整体运行效率。 功能部件：1）输入设备将程序和数据以机器所能识别和接受的信息形式输入到计算机 2）输出设备将计算机处理的结果以人们所能接受的形式或其他系统所要求的信息形式输出 3）存储器存储器是计算机的存储部件，用来存放程序和数据存储器分为主存储器（也称为内存储器）和辅助存储器（也称为外存储器）。 主存储器的结构： 地址寄存器（MAR）存放访存地址，经过地址译码后找到所选的存储单元。位数对应着存储单元的个数，如MAR为10位，则有${2}^{10}=1024B=1K$个存储单元。MAR的长度与PC长度相等。数据寄存器（MDR）是主存和其他部件的中介机构，用于暂存要从存储器中读或写的信息。MDR的位数和存储字长相等，一般为字节的二次幂整数倍，如8位、16位、32位、64位等。 4）运算器计算机的执行部件，用于对数据进行加工处理，完成算术运算和逻辑运算运算器的核心是算术逻辑单元ALU，包含若干通用寄存器，如累加器（ACC）、乘商寄存器（MQ）、操作数寄存器（X）、变址寄存器（IX）、基址寄存器（BR）等。运算器还包含程序状态寄存器（PSW）。 5）控制器计算机的指挥中心，指挥各部件自动协调地进行工作控制器由程序计数器（PC）、指令寄存器（IR）、控制单元（CU）组成。 0x04. 计算机软件分类1. 系统软件是一组保证计算机系统高效、正确运行的基础软件，通常作为系统资源提供给用户使用。 2. 应用软件是指用户为解决某个应用领域中的各类问题而编制的程序。注：数据库管理系统（DBMS）是位于用户和操作系统之间的一层数据管理软件，是系统软件；数据库系统（DBS）是指计算机系统中引入数据库后的系统，一般由数据库、数据库管理系统、数据库管理员（DBA）和应用系统构成。 0x05. 计算机工作过程1）把程序和数据装入到主存储器中2）从程序的起始地址运行程序3）用程序的首地址从存储器中取第一条指令，经过译码、执行步骤等控制计算机各功能部件协同运行，完成该指令功能，并计算下一条指令地址。4）用新得到的指令地址继续读出第二条指令并执行，直到程序结束为止 例：将指令地址码指示的存储单元中的操作数取出后送至运算器的ACC中（操作码为OP(IR)，地址码为Ad(IR)）取指令：PC-&gt;MAR-&gt;M-&gt;MDR-&gt;IR; (PC)+1-&gt;PC分析指令：OP(IR)-&gt;CU执行指令：Ad(IR)-&gt;MAR-&gt;M-&gt;MDR-&gt;ACC 0x06. 计算机系统多层次结构1. 微程序机器层由机器硬件直接执行微指令 2. 传统机器语言层由微程序解释机器指令系统 3. 操作系统层混合层，包含机器指令和广义指令。 4. 汇编语言层由汇编程序支持和执行 5. 高级语言层面向用户，由高级语言编译程序支持和执行 本课程讨论第一层和第二层的组成原理与设计。","categories":[{"name":"计算机组成原理","slug":"计算机组成原理","permalink":"https://SummerHello12138.github.io/categories/计算机组成原理/"}],"tags":[{"name":"计算机组成原理","slug":"计算机组成原理","permalink":"https://SummerHello12138.github.io/tags/计算机组成原理/"},{"name":"概览","slug":"概览","permalink":"https://SummerHello12138.github.io/tags/概览/"}]}]}