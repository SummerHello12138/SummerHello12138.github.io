<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Summer&#39;s 博客</title>
  
  <subtitle>一只菜鸟级的安全狗</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://SummerHello12138.github.io/"/>
  <updated>2018-09-16T11:05:46.161Z</updated>
  <id>https://SummerHello12138.github.io/</id>
  
  <author>
    <name>Xia Benhui</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2019计算机考研大纲</title>
    <link href="https://SummerHello12138.github.io/2018/09/16/%E8%80%83%E7%A0%94%E5%A4%A7%E7%BA%B2/"/>
    <id>https://SummerHello12138.github.io/2018/09/16/考研大纲/</id>
    <published>2018-09-16T10:04:06.335Z</published>
    <updated>2018-09-16T11:05:46.161Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2019计算机考研大纲"><a href="#2019计算机考研大纲" class="headerlink" title="2019计算机考研大纲"></a>2019计算机考研大纲</h1><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p><strong>【考查目标】</strong></p><ol><li>掌握数据结构的基本概念、基本原理和基本方法。</li><li>掌握数据结构的逻辑结构、存储结构及基本操作的实现，能够对算法进行基本的时间复杂度与空间复杂度的分析。</li><li>能够运用数据结构基本原理和方法进行问题的分析与求解，具备采用C或C++语言设计与实现算法的能力。</li></ol><p><strong>一、线性表</strong><br>（一）线性表的定义和基本操作<br>（二）线性表的实现<br>1）顺序存储<br>2）链式存储<br>3）线性表的应用</p><p><strong>二、栈、队列和数组</strong><br>（一）栈和队列的基本概念<br>（二）栈和队列的顺序存储结构<br>（三）栈和队列的链式存储结构<br>（四）栈和队列的应用<br>（五）特殊矩阵的压缩存储</p><p><strong>三、树与二叉树</strong><br>（一）树的基本概念<br>（二）二叉树<br>1）二叉树的定义及其主要特征<br>2）二叉树的顺序存储结构和链式存储结构<br>3）二叉树的遍历<br>4）线索二叉树的基本概念和构造<br>（三）树、森林<br>1）树的存储结构<br>2）森林与二叉树的转换<br>3）树和森林的遍历<br>（四）树与二叉树的应用<br>1）二叉排序树<br>2）平衡二叉树<br>3）哈夫曼（Huffman）树和哈夫曼编码</p><p><strong>四、图</strong><br>(一)图的基本概念<br>(二)图的存储及基本操作<br>1）邻接矩阵法<br>2）邻接表法<br>3）邻接多重表、十字链表<br>(三)图的遍历<br>1）深度优先搜索（DFS）<br>2）广度优先搜索（BFS）<br>(四)图的基本应用<br>1）最小（代价）生成树<br>2）最短路径<br>3）拓扑排序<br>4）关键路径</p><p><strong>五、查找</strong><br>(一)查找的基本概念<br>(二)顺序查找法<br>(三)分块查找法<br>(四)折半查找法<br>(五)B树及其基本操作、B+树的基本概念<br>(六)散列(Hash)表<br>(七)字符串模式匹配<br>(八)查找算法的分析及应用</p><p><strong>六、排序</strong><br>(一)排序的基本概念<br>(二)插入排序<br>1）直接插入排序<br>2）折半插入排序<br>(三)起泡排序(BubbleSort)<br>(四)简单选择排序<br>(五)希尔排序(ShellSort)<br>(六)快速排序<br>(七)堆排序<br>(八)二路归并排序(MergeSort)<br>(九)基数排序<br>(十)外部排序<br>(十一)各种排序算法的比较<br>(十二)排序算法的应用</p><h2 id="计算机组成原理"><a href="#计算机组成原理" class="headerlink" title="计算机组成原理"></a>计算机组成原理</h2><p><strong>【考查目标】</strong></p><ol><li>理解单处理器计算机系统中各部件的内部工作原理、组成结构以及相互连接方式，具有完整的计算机系统的整机概念。</li><li>理解计算机系统层次化结构概念，熟悉硬件与软件之间的界面，掌握指令集体系结构的基本知识和基本实现方法。</li><li>能够综合运用计算机组成的基本原理和基本方法，对有关计算机硬件系统中的理论和实际问题进行计算、分析，对一些基本部件进行简单设计;并能对高级程序设计语言(如C语言)中的相关问题进行分析。</li></ol><p><strong>一、计算机系统概述</strong><br>(一)计算机发展历程<br>(二)计算机系统层次结构</p><ol><li>计算机系统的基本组成</li><li>计算机硬件的基本组成</li><li>计算机软件和硬件的关系</li><li>计算机系统的工作过程</li></ol><p>(三)计算机性能指标<br>吞吐量、响应时间，CPU时钟周期、主频、CPI、CPU执行时间，MIPS、MFLOPS、GFLOPS、TFLOPS、PFLOPS。<br><strong>二、数据的表示和运算</strong><br>(一)数制与编码</p><ol><li>进位计数制及其相互转换</li><li>真值和机器数</li><li>BCD码</li><li>字符与字符串</li><li>校验码</li></ol><p>(二)定点数的表示和运算</p><ol><li>定点数的表示<br>无符号数的表示，带符号整数的表示。</li><li>定点数的运算<br>定点数的位移运算，原码定点数的加/减运算，补码定点数的加/减运算，定点数的乘/除运算，溢出概念和判别方法。</li></ol><p>(三)浮点数的表示和运算</p><ol><li>浮点数的表示<br>IEEE754标准。</li><li>浮点数的加/减运算</li></ol><p>(四)算术逻辑单元ALU</p><ol><li>串行加法器和并行加法器</li><li>算术逻辑单元ALU的功能和结构</li></ol><p><strong>三、存储器层次结构</strong><br>(一)存储器的分类<br>(二)存储器的层次化结构<br>(三)半导体随机存取存储器<br>　　1.SRAM存储器<br>　　2.DRAM存储器<br>　　3.只读存储器<br>　　4.Flash存储器<br>(四)主存储器与CPU的连接<br>(五)双口RAM和多模块存储器<br>(六)高速缓冲存储器(Cache)<br>　　1.Cache的基本工作原理<br>　　2.Cach和主存之间的映射方式<br>　　3.Cache中主存块的替换算法<br>　　4.Cache写策略<br>(七)虚拟存储器<br>　　1.虚拟存储器的基本概念<br>　　2.页式虚拟存储器<br>　　3.段式虚拟存储器<br>　　4.段页式虚拟存储器<br>　　5.TLB(快表)<br><strong>四、指令系统</strong><br>(一)指令格式<br>　　1.指令的基本格式<br>　　2.定长操作码指令格式<br>　　3.扩展操作码指令格式<br>(二)指令的寻址方式<br>　　1.有效地址的概念<br>　　2.数据寻址和指令寻址<br>　　3.常见寻址方式<br>(三)CISC和RISC的基本概念<br><strong>五、中央处理器（CPU）</strong><br>(一)CPU的功能和基本结构<br>(二)指令执行过程<br>(三)数据通路的功能和基本结构<br>(四)控制器的功能和工作原理<br>　　1.硬布线控制器<br>　　2.微程序控制器<br>　　微程序、微指令和微命令，微指令格式，微命令的编码方式，微地址的形成方式。<br>(五)指令流水线<br>　　1.指令流水线的基本概念<br>　　2.指令流水线的基本实现<br>　　3.超标量和动态流水线的基本概念<br><strong>六、总线</strong><br>(一)总线概述<br>　　1.总线的基本概念<br>　　2.总线的分类<br>　　3.总线的组成及性能指标<br>(二)总线仲裁<br>　　1.集中仲裁方式<br>　　2.分布仲裁方式<br>(三)总线操作和定时<br>　　1.同步定时方式<br>　　2.异步定时方式<br>(四)总线标准<br><strong>七、输入输出（I/O）系统</strong><br>(一)I/O系统基本概念<br>(二)外部设备<br>　　1.输入设备：键盘、鼠标<br>　　2.输出设备：显示器、打印机<br>　　3.外存储器：硬盘存储器、磁盘阵列、光盘存储器<br>(三)I/O接口(I/O控制器)<br>　　1.I/O接口的功能和基本结构<br>　　2.I/O端口及其编址<br>(四)I/O方式<br>　　1.程序查询方式<br>　　2.程序中断方式<br>　　中断的基本概念，中断响应过程，中断处理过程，多重中断和中断屏蔽的概念。<br>　　3.DMA方式<br>　　DMA控制器的组成，DMA传送过程。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;2019计算机考研大纲&quot;&gt;&lt;a href=&quot;#2019计算机考研大纲&quot; class=&quot;headerlink&quot; title=&quot;2019计算机考研大纲&quot;&gt;&lt;/a&gt;2019计算机考研大纲&lt;/h1&gt;&lt;h2 id=&quot;数据结构&quot;&gt;&lt;a href=&quot;#数据结构&quot; class=&quot;
      
    
    </summary>
    
      <category term="考研" scheme="https://SummerHello12138.github.io/categories/%E8%80%83%E7%A0%94/"/>
    
    
      <category term="考研" scheme="https://SummerHello12138.github.io/tags/%E8%80%83%E7%A0%94/"/>
    
      <category term="数据结构" scheme="https://SummerHello12138.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="计算机组成原理" scheme="https://SummerHello12138.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>图的遍历</title>
    <link href="https://SummerHello12138.github.io/2018/09/11/15366684711365/"/>
    <id>https://SummerHello12138.github.io/2018/09/11/15366684711365/</id>
    <published>2018-09-11T12:21:11.138Z</published>
    <updated>2018-09-15T14:25:25.404Z</updated>
    
    <content type="html"><![CDATA[<h1 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 邻接矩阵的深度优先递归算法 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(MGraph G, <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> j;</span><br><span class="line"> visited[i] = TRUE;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">"%c "</span>, G.vexs[i]);<span class="comment">/* 打印顶点，也可以其它操作 */</span></span><br><span class="line"><span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; G.numVertexes; j++)</span><br><span class="line"><span class="keyword">if</span>(G.arc[i][j] == <span class="number">1</span> &amp;&amp; !visited[j])</span><br><span class="line"> DFS(G, j);<span class="comment">/* 对为访问的邻接顶点递归调用 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 邻接矩阵的深度遍历操作 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFSTraverse</span><span class="params">(MGraph G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"> <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; G.numVertexes; i++)</span><br><span class="line"> visited[i] = FALSE; <span class="comment">/* 初始所有顶点状态都是未访问过状态 */</span></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; G.numVertexes; i++)</span><br><span class="line"> <span class="keyword">if</span>(!visited[i]) <span class="comment">/* 对未访问过的顶点调用DFS，若是连通图，只会执行一次 */</span> </span><br><span class="line">DFS(G, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 利用邻接矩阵构建邻接表 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateALGraph</span><span class="params">(MGraph G,GraphAdjList *GL)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,j;</span><br><span class="line">EdgeNode *e;</span><br><span class="line"></span><br><span class="line">*GL = (GraphAdjList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(graphAdjList));</span><br><span class="line"></span><br><span class="line">(*GL)-&gt;numVertexes=G.numVertexes;</span><br><span class="line">(*GL)-&gt;numEdges=G.numEdges;</span><br><span class="line"><span class="keyword">for</span>(i= <span class="number">0</span>;i &lt;G.numVertexes;i++) <span class="comment">/* 读入顶点信息,建立顶点表 */</span>   </span><br><span class="line">&#123;</span><br><span class="line">(*GL)-&gt;adjList[i].in=<span class="number">0</span>;</span><br><span class="line">(*GL)-&gt;adjList[i].data=G.vexs[i];</span><br><span class="line">(*GL)-&gt;adjList[i].firstedge=<span class="literal">NULL</span>; <span class="comment">/* 将边表置为空表 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.numVertexes;i++) <span class="comment">/* 建立边表 */</span></span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;G.numVertexes;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (G.arc[i][j]==<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">e=(EdgeNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(EdgeNode));</span><br><span class="line">e-&gt;adjvex=j;<span class="comment">/* 邻接序号为j */</span>                         </span><br><span class="line">e-&gt;next=(*GL)-&gt;adjList[i].firstedge;<span class="comment">/* 将当前顶点上的指向的结点指针赋值给e */</span></span><br><span class="line">(*GL)-&gt;adjList[i].firstedge=e;<span class="comment">/* 将当前顶点的指针指向e */</span>   </span><br><span class="line">(*GL)-&gt;adjList[j].in++;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Boolean visited[MAXSIZE]; <span class="comment">/* 访问标志的数组 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 邻接表的深度优先递归算法 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(GraphAdjList GL, <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">EdgeNode *p;</span><br><span class="line"> visited[i] = TRUE;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">"%c "</span>,GL-&gt;adjList[i].data);<span class="comment">/* 打印顶点,也可以其它操作 */</span></span><br><span class="line">p = GL-&gt;adjList[i].firstedge;</span><br><span class="line"><span class="keyword">while</span>(p)</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">if</span>(!visited[p-&gt;adjvex])</span><br><span class="line"> DFS(GL, p-&gt;adjvex);<span class="comment">/* 对为访问的邻接顶点递归调用 */</span></span><br><span class="line">p = p-&gt;next;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 邻接表的深度遍历操作 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFSTraverse</span><span class="params">(GraphAdjList GL)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"> <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; GL-&gt;numVertexes; i++)</span><br><span class="line"> visited[i] = FALSE; <span class="comment">/* 初始所有顶点状态都是未访问过状态 */</span></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; GL-&gt;numVertexes; i++)</span><br><span class="line"> <span class="keyword">if</span>(!visited[i]) <span class="comment">/* 对未访问过的顶点调用DFS,若是连通图,只会执行一次 */</span> </span><br><span class="line">DFS(GL, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 邻接矩阵的广度遍历算法 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFSTraverse</span><span class="params">(MGraph G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i, j;</span><br><span class="line">Queue Q;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; G.numVertexes; i++)</span><br><span class="line">       visited[i] = FALSE;</span><br><span class="line">    InitQueue(&amp;Q);<span class="comment">/* 初始化一辅助用的队列 */</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; G.numVertexes; i++)  <span class="comment">/* 对每一个顶点做循环 */</span></span><br><span class="line">    &#123;</span><br><span class="line"><span class="keyword">if</span> (!visited[i])<span class="comment">/* 若是未访问过就处理 */</span></span><br><span class="line">&#123;</span><br><span class="line">visited[i]=TRUE;<span class="comment">/* 设置当前顶点访问过 */</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c "</span>, G.vexs[i]);<span class="comment">/* 打印顶点，也可以其它操作 */</span></span><br><span class="line">EnQueue(&amp;Q,i);<span class="comment">/* 将此顶点入队列 */</span></span><br><span class="line"><span class="keyword">while</span>(!QueueEmpty(Q))<span class="comment">/* 若当前队列不为空 */</span></span><br><span class="line">&#123;</span><br><span class="line">DeQueue(&amp;Q,&amp;i);<span class="comment">/* 将队对元素出队列，赋值给i */</span></span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;G.numVertexes;j++) </span><br><span class="line">&#123; </span><br><span class="line"><span class="comment">/* 判断其它顶点若与当前顶点存在边且未访问过  */</span></span><br><span class="line"><span class="keyword">if</span>(G.arc[i][j] == <span class="number">1</span> &amp;&amp; !visited[j]) </span><br><span class="line">&#123; </span><br><span class="line"> visited[j]=TRUE;<span class="comment">/* 将找到的此顶点标记为已访问 */</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c "</span>, G.vexs[j]);<span class="comment">/* 打印顶点 */</span></span><br><span class="line">EnQueue(&amp;Q,j);<span class="comment">/* 将找到的此顶点入队列  */</span></span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 邻接表的广度遍历算法 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFSTraverse</span><span class="params">(GraphAdjList GL)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line">    EdgeNode *p;</span><br><span class="line">Queue Q;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; GL-&gt;numVertexes; i++)</span><br><span class="line">       visited[i] = FALSE;</span><br><span class="line">    InitQueue(&amp;Q);</span><br><span class="line">   <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; GL-&gt;numVertexes; i++)</span><br><span class="line">   &#123;</span><br><span class="line"><span class="keyword">if</span> (!visited[i])</span><br><span class="line">&#123;</span><br><span class="line">visited[i]=TRUE;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c "</span>,GL-&gt;adjList[i].data);<span class="comment">/* 打印顶点,也可以其它操作 */</span></span><br><span class="line">EnQueue(&amp;Q,i);</span><br><span class="line"><span class="keyword">while</span>(!QueueEmpty(Q))</span><br><span class="line">&#123;</span><br><span class="line">DeQueue(&amp;Q,&amp;i);</span><br><span class="line">p = GL-&gt;adjList[i].firstedge;<span class="comment">/* 找到当前顶点的边表链表头指针 */</span></span><br><span class="line"><span class="keyword">while</span>(p)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!visited[p-&gt;adjvex])<span class="comment">/* 若此顶点未被访问 */</span></span><br><span class="line"> &#123;</span><br><span class="line"> visited[p-&gt;adjvex]=TRUE;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c "</span>,GL-&gt;adjList[p-&gt;adjvex].data);</span><br><span class="line">EnQueue(&amp;Q,p-&gt;adjvex);<span class="comment">/* 将此顶点入队列 */</span></span><br><span class="line">&#125;</span><br><span class="line">p = p-&gt;next;<span class="comment">/* 指针指向下一个邻接点 */</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;DFS&quot;&gt;&lt;a href=&quot;#DFS&quot; class=&quot;headerlink&quot; title=&quot;DFS&quot;&gt;&lt;/a&gt;DFS&lt;/h1&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span 
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>计算机组成原理</title>
    <link href="https://SummerHello12138.github.io/2018/07/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    <id>https://SummerHello12138.github.io/2018/07/27/计算机组成原理/</id>
    <published>2018-07-27T03:11:11.421Z</published>
    <updated>2018-09-15T14:25:12.093Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="0x00-计算机发展"><a href="#0x00-计算机发展" class="headerlink" title="0x00. 计算机发展"></a>0x00. 计算机发展</h2><h5 id="1-第一代（1946～1957）：电子管时代"><a href="#1-第一代（1946～1957）：电子管时代" class="headerlink" title="1. 第一代（1946～1957）：电子管时代"></a>1. 第一代（1946～1957）：电子管时代</h5><p>容量小、体积庞大、成本高、运算速度低，一般每秒几千到几万次</p><h5 id="2-第二代（1958～1964）：晶体管时代"><a href="#2-第二代（1958～1964）：晶体管时代" class="headerlink" title="2. 第二代（1958～1964）：晶体管时代"></a>2. 第二代（1958～1964）：晶体管时代</h5><p>运算速度提高到每秒几万到几十万次，操作系统雏形</p><h5 id="3-第三代（1965～1971）：中小规模集成电路时代"><a href="#3-第三代（1965～1971）：中小规模集成电路时代" class="headerlink" title="3. 第三代（1965～1971）：中小规模集成电路时代"></a>3. 第三代（1965～1971）：中小规模集成电路时代</h5><p>出现分时操作系统</p><h5 id="4-第四代（1972～今）：超大规模集成电路时代"><a href="#4-第四代（1972～今）：超大规模集成电路时代" class="headerlink" title="4. 第四代（1972～今）：超大规模集成电路时代"></a>4. 第四代（1972～今）：超大规模集成电路时代</h5><h2 id="0x01-摩尔定律"><a href="#0x01-摩尔定律" class="headerlink" title="0x01. 摩尔定律"></a>0x01. 摩尔定律</h2><p><strong>摩尔定律</strong>，当价格不变时，集成电路上可容纳的晶体管数目，约每隔18个月便会增加一倍，性能也将提升一倍。</p><h2 id="0x02-计算机的分类"><a href="#0x02-计算机的分类" class="headerlink" title="0x02. 计算机的分类"></a>0x02. 计算机的分类</h2><p>1）电子计算机分为<strong>电子模拟计算机</strong>和<strong>电子数字计算机</strong>。<br>2）用途：专用计算机、通用计算机<br>3）通用计算机：巨型机、大型机、小型机、微型机、单片机<br>4）指令和数据流：</p><ul><li>单指令和单数据流系统（SISD），冯·诺依曼系统</li><li>单指令和多数据流系统（SIMD），阵列处理器和向量处理器</li><li>多指令和单数据流系统（MISD），不存在</li><li>多指令和多数据流系统（MIMD），多处理器和多计算机系统</li></ul><h2 id="0x03-计算机硬件组成"><a href="#0x03-计算机硬件组成" class="headerlink" title="0x03. 计算机硬件组成"></a>0x03. 计算机硬件组成</h2><h5 id="1-早期冯·诺依曼机"><a href="#1-早期冯·诺依曼机" class="headerlink" title="1. 早期冯·诺依曼机"></a>1. 早期冯·诺依曼机</h5><p>结构：<br><img src="media/15326610714199/15326960197438.jpg" alt=""><br>原因：早期运算器和控制器分离，存储器容量很小，故而设计成以运算器为中心，其他部件都通过运算器完成信息的传递。</p><p>特点：<br>1）计算机硬件系统由运算器、存储器、控制器、输入设备和输出设备组成<br>2）指令和数据以同等地位存于存储器内，并可以按地址寻访<br>3）指令和数据均用二进制代码表示<br>4）指令由操作码和地址码组成，操作码用来表示操作的性质，地址码用来表示操作数载存储器中的位置<br>5）指令在存储器内按顺序存放<br>6）早期的冯·诺伊曼机以运算器为中心</p><h5 id="2-现代计算机结构"><a href="#2-现代计算机结构" class="headerlink" title="2. 现代计算机结构"></a>2. 现代计算机结构</h5><p>结构：<br><img src="media/15326610714199/15326966590775.jpg" alt=""><br>原因：I/O操作尽可能绕过CPU，直接在I/O设备和存储器之间完成，以提高系统的整体运行效率。</p><p>功能部件：<br>1）输入设备<br>将程序和数据以机器所能识别和接受的信息形式输入到计算机</p><p>2）输出设备<br>将计算机处理的结果以人们所能接受的形式或其他系统所要求的信息形式输出</p><p>3）存储器<br>存储器是计算机的存储部件，用来存放程序和数据<br>存储器分为<strong>主存储器（也称为内存储器）</strong>和<strong>辅助存储器（也称为外存储器）</strong>。</p><p>主存储器的结构：<br><img src="media/15326610714199/15326973507330.jpg" alt=""></p><p><strong>地址寄存器（MAR）</strong>存放访存地址，经过地址译码后找到所选的存储单元。位数对应着存储单元的个数，如MAR为10位，则有${2}^{10}=1024B=1K$个存储单元。<strong>MAR的长度与PC长度相等</strong>。<br><strong>数据寄存器（MDR）</strong>是主存和其他部件的中介机构，用于暂存要从存储器中读或写的信息。<strong>MDR的位数和存储字长相等</strong>，一般为字节的二次幂整数倍，如8位、16位、32位、64位等。</p><p>4）运算器<br>计算机的执行部件，用于对数据进行加工处理，完成算术运算和逻辑运算<br>运算器的核心是算术逻辑单元ALU，包含若干通用寄存器，如累加器（ACC）、乘商寄存器（MQ）、操作数寄存器（X）、变址寄存器（IX）、基址寄存器（BR）等。<br>运算器还包含程序状态寄存器（PSW）。</p><p>5）控制器<br>计算机的指挥中心，指挥各部件自动协调地进行工作<br>控制器由程序计数器（PC）、指令寄存器（IR）、控制单元（CU）组成。</p><h2 id="0x04-计算机软件分类"><a href="#0x04-计算机软件分类" class="headerlink" title="0x04. 计算机软件分类"></a>0x04. 计算机软件分类</h2><h5 id="1-系统软件"><a href="#1-系统软件" class="headerlink" title="1. 系统软件"></a>1. 系统软件</h5><p>是一组保证计算机系统高效、正确运行的基础软件，通常作为系统资源提供给用户使用。</p><h5 id="2-应用软件"><a href="#2-应用软件" class="headerlink" title="2. 应用软件"></a>2. 应用软件</h5><p>是指用户为解决某个应用领域中的各类问题而编制的程序。<br><strong>注：</strong>数据库管理系统（DBMS）是位于用户和操作系统之间的一层数据管理软件，是<strong>系统软件</strong>；数据库系统（DBS）是指计算机系统中引入数据库后的系统，一般由数据库、数据库管理系统、数据库管理员（DBA）和应用系统构成。</p><h2 id="0x05-计算机工作过程"><a href="#0x05-计算机工作过程" class="headerlink" title="0x05. 计算机工作过程"></a>0x05. 计算机工作过程</h2><p>1）把程序和数据装入到主存储器中<br>2）从程序的起始地址运行程序<br>3）用程序的首地址从存储器中取第一条指令，经过译码、执行步骤等控制计算机各功能部件协同运行，完成该指令功能，并计算下一条指令地址。<br>4）用新得到的指令地址继续读出第二条指令并执行，直到程序结束为止</p><p>例：将指令地址码指示的存储单元中的操作数取出后送至运算器的ACC中（操作码为OP(IR)，地址码为Ad(IR)）<br>取指令：PC-&gt;MAR-&gt;M-&gt;MDR-&gt;IR;    (PC)+1-&gt;PC<br>分析指令：OP(IR)-&gt;CU<br>执行指令：Ad(IR)-&gt;MAR-&gt;M-&gt;MDR-&gt;ACC</p><h2 id="0x06-计算机系统多层次结构"><a href="#0x06-计算机系统多层次结构" class="headerlink" title="0x06. 计算机系统多层次结构"></a>0x06. 计算机系统多层次结构</h2><h5 id="1-微程序机器层"><a href="#1-微程序机器层" class="headerlink" title="1. 微程序机器层"></a>1. 微程序机器层</h5><p>由机器硬件直接执行微指令</p><h5 id="2-传统机器语言层"><a href="#2-传统机器语言层" class="headerlink" title="2. 传统机器语言层"></a>2. 传统机器语言层</h5><p>由微程序解释机器指令系统</p><h5 id="3-操作系统层"><a href="#3-操作系统层" class="headerlink" title="3. 操作系统层"></a>3. 操作系统层</h5><p>混合层，包含机器指令和广义指令。</p><h5 id="4-汇编语言层"><a href="#4-汇编语言层" class="headerlink" title="4. 汇编语言层"></a>4. 汇编语言层</h5><p>由汇编程序支持和执行</p><h5 id="5-高级语言层"><a href="#5-高级语言层" class="headerlink" title="5. 高级语言层"></a>5. 高级语言层</h5><p>面向用户，由高级语言编译程序支持和执行</p><p><strong>本课程讨论第一层和第二层</strong>的组成原理与设计。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;h2 id=&quot;0x00-计算机发展&quot;&gt;&lt;a href=&quot;#0x00-计算机发展&quot; class=&quot;headerlink&quot; title=&quot;0x00.
      
    
    </summary>
    
    
  </entry>
  
</feed>
